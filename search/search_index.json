{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Kumite","text":"<p>This project develops a platform to enable algorithms to compete against each others.</p>"},{"location":"#architecture","title":"Architecture","text":"<p>The main component is the <code>contest-server</code>, which is a essentially back-end offering an API.</p> <p>The <code>contest-server</code> embeds a <code>vue-js</code> application, which can be used to: - get a <code>refresh_token</code> (which is the secret authenticating bots)  - browse through games and contests.</p>"},{"location":"#how-to-develop-your-own-bot","title":"How to develop your own bot","text":""},{"location":"#typical-gaming-loop","title":"Typical gaming loop","text":"<p>A normal gaming loop is the following:</p> <ol> <li>Loop through <code>game</code>s matching your criteria</li> <li>For each matching <code>game</code>s, loop through contests matching your criteria</li> <li>For each <code>contest</code>, join as a playing-<code>player</code>/<code>contender</code>.</li> <li>Submit <code>move</code>s, or wait until its your turn.</li> <li>Repeat step4 until the game is over or you're fine with your score</li> </ol>"},{"location":"#game-categories","title":"Game categories","text":"<p>Games are tagged to help categorizing them. Main tags are:</p> <ul> <li><code>optimization</code>: optimization games are solo games, with as goal the submission of the best solution.</li> <li><code>1v1</code>: Exactly 2 <code>player</code>s compete one against the other.</li> <li><code>turn-based</code>: Each <code>player</code> plays one after the other. These could be played at slow pace. They might be rules to limit the duration of each player turn.</li> <li><code>real-time</code>: The board state evolve through time, even if players do not submit any move.</li> </ul>"},{"location":"api/","title":"API","text":"<p>The API can also be browsed through:</p> <ul> <li>OpenAPI/Swagger</li> <li>Java Webflux Example</li> </ul> <p>Here, we present an overview of the main entry-points.</p>"},{"location":"api/#login-api","title":"Login API","text":"<p>Given a <code>refresh_token</code> fetched manually on /html/me, one can: <ul> <li>Create an <code>access_token</code> with <code>GET /api/v1/oauth2/token?player_id=somePlayerId</code></li> </ul> <p>A robot authenticates itself with an <code>access_token</code>. It is provided to the API with an <code>Authentication</code> header:</p>"},{"location":"api/#browsing-api","title":"Browsing API","text":"<p>Given an <code>access_token</code> fetched with the Login API, one can:</p> <ul> <li>Search <code>game</code>s with <code>GET /api/v1/games?tag=optimization</code>.</li> <li>Search <code>contest</code>s with <code>GET /api/v1/contests?accept_players=true</code>.</li> </ul>"},{"location":"api/#contender-api","title":"Contender API","text":"<p>Once you found a relevant contest, once can:</p> <ul> <li>Preview the <code>board</code> of the <code>contest</code> with <code>GET /api/v1/board?contest_id=234</code></li> <li>Join the <code>contest</code> as contender with <code>POST /api/v1/board/player?contest_id=234&amp;player_id=123</code></li> <li>Load the <code>board</code> of the <code>contest</code> as given <code>player</code> with <code>GET /api/v1/board?contest_id=234&amp;player_id=123</code></li> <li>Play a <code>move</code> with <code>POST /api/v1/board/move?contest_id=234&amp;player_id=123</code></li> </ul>"},{"location":"authentication/","title":"Authentication","text":""},{"location":"authentication/#access_token-usage","title":"access_token usage","text":"<p>A robot authenticates itself with an <code>access_token</code>. It is provided to the API with an <code>Authentication</code> header:</p> <pre><code>curl -H \"Authorization: OAuth &lt;ACCESS_TOKEN&gt;\" \n    &lt;HOST&gt;/api/v1/games\n</code></pre> <p><code>access-token</code>s are: - short-lived: they generally expires after 1 hour. - attached to a single playerId (i.e. the playerId can be seen as a <code>clientId</code>).</p>"},{"location":"authentication/#access_token-generation","title":"access_token generation","text":"<p>An access_token is generated given a <code>refresh_token</code></p> <pre><code>curl -H \"Authorization: OAuth &lt;REFRESH_TOKEN&gt;\" \n    &lt;HOST&gt;/api/v1/oauth2/token?refresh_token=true\n</code></pre>"},{"location":"authentication/#how-to-get-a-refresh_token","title":"How to get a <code>refresh_token</code>","text":"<p>A <code>refresh_token</code> has to be fetched manually:</p> <ol> <li>Connect to  <li>Submit the form on /html/me. This <code>refresh_token</code> is long-lived: it expires after 1 year. <li>Store it right away in a safe place, for instance as environment variable.</li> <p><code>refresh_token</code>s are: - long-lived: they are valid for 1 year after their generation - can be associated to 1/many/all playerIds. - JWS: they can be open to work on their claims. - can be banned individually given their <code>jti</code> claim.</p>"},{"location":"authentication/#is-it-awkward-that-a-refresh_token-manages-multiple-playerids","title":"Is it awkward that a <code>refresh_token</code> manages multiple <code>playerId</code>s?","text":"<ul> <li>From the <code>access-token</code> perspective, the <code>playerId</code> can be interpreted as a <code>clientId</code>.</li> <li>But a <code>refresh_token</code> can be attached to multiple playerIds.</li> <li>The goal if this design is to make it easier to manage multiple players/strategies through a single  secret/<code>refresh_token</code>.</li> </ul>"},{"location":"authentication/#which-playerids-can-be-played-given-a-refresh_token","title":"Which playerIds can be played given a <code>refresh_token</code>","text":"<p>The <code>playerIds</code> claim has type string-list. It holds the list of playerId playable by given <code>refresh_token</code>.</p> <p>You can generate a <code>refresh_token</code> for any given set of playerIds at generation time.</p> <p>BEWARE: we shall provide a way for a <code>refresh_token</code> to be valid for all playerIds, even those not created yet.</p>"},{"location":"authentication/#parallel-with-oauth2-protocol","title":"Parallel with OAuth2 protocol","text":"<p>We refer to the wording <code>access_token</code> and <code>refresh_token</code>. However, we do not follow strictly OAuth2 regarding these tokens. This would be done in a later iteration, as it would require to split the Resource Server (serving the business API given an access_token) and the Authentication Server (which would provide and receive refresh_token).</p>"},{"location":"board-mutations/","title":"Board mutations","text":"<p>A board can mutate for various reasons:</p> <ul> <li>a contender joined the contest</li> <li>a contender played a move</li> <li>a time-frame happened (for <code>real-time</code> games)</li> <li>the contest is <code>gameover</code> (due to game rules, or an external reasons (e.g. some exception))</li> </ul>"},{"location":"board-mutations/#concurrency-model","title":"Concurrency model","text":"<p>To guarantee consistency through board mutations, all mutations are done through a single thread. This is managed by <code>BoardLifecycleManager</code>. There may be multiple threads mutating boards, which is safe as long as given contestId is always managed by the same thread (e.g. through a hash <code>contestId =&gt; threadId</code>).</p>"},{"location":"board-mutations/#persistence-of-the-board","title":"Persistence of the board","text":"<p>The board state is split in multiple concepts/repositories:</p> <ul> <li>ContestConstantMetadata: these are defined when the contest is created and do not change through time</li> <li>IKumiteBoard: this is the custom board, as defined per the game. It holds the whole board state, and shall evolve only through <code>BoardLifecycleManager</code>.</li> <li>BoardDynamicMetadata: holds dynamic metadata about a board, without any board specificity. It includes the gameOver (especially if it has been forced out of the game rules).</li> </ul>"},{"location":"board-mutations/#events","title":"Events","text":"<p>To prevent the need to poll the contest game, nor to couple too many components together, we rely on an <code>EventBus</code> to notify about the contest lifecycle.</p> <p>Events include:</p> <ul> <li>ContestIsCreated</li> <li>PlayerJoinedBoard</li> <li>PlayerCanMove: send when a player switched from <code>not being able to move</code> to <code>being able to me</code>.</li> <li>PlayerMoved</li> <li>ContestIsGameover</li> </ul>"},{"location":"board-mutations/#boardstateid","title":"BoardStateId","text":"<p>The boardStateId can be used to:</p> <ul> <li>know if current board is the latest board or not: it is useful not to have to fetch/analyze/poll the whole board.</li> </ul>"},{"location":"lexicon/","title":"Lexicon","text":""},{"location":"lexicon/#game","title":"Game","text":"<p>A game is a set of rules defining winning, losing or scoring conditions. A Game is not played by itself, but on a per-contest basis.</p>"},{"location":"lexicon/#user","title":"User","text":"<p>A user is a human User, connected for instance through its Github account.</p> <p>It is identified by the identity referential (e.g. <code>oauth2.providerId+sub</code>).</p> <p>(It is unclear how we would manage joined-users, a.k.a. same human connecting through different identity referentials (e.g. Github and Google, with a common email address)).</p>"},{"location":"lexicon/#account","title":"Account","text":"<p>The set of resources referring by an <code>accountId</code>.</p> <p>It is identified by an <code>UUID</code>.</p>"},{"location":"lexicon/#player","title":"Player","text":"<p>A robot identifier, attached to a <code>account</code>, and able to join <code>contest</code>s.</p> <p>It is identified by an <code>UUID</code>.</p>"},{"location":"lexicon/#contest","title":"Contest","text":"<p>A contest is an instance of a <code>Game</code>. It can be joined by playing <code>player</code>s (also referred to as <code>contender</code>s) and viewing <code>player</code>s.</p> <ul> <li>A <code>contender</code> can play <code>move</code>s, following the <code>game</code> rules.</li> <li>A <code>viewer</code> can not play any <code>move</code>, but he can see the whole board, independently of any <code>fog-of-war</code>.</li> </ul> <p>It is identified by an <code>UUID</code>.</p>"},{"location":"lexicon/#board","title":"Board","text":"<p>Each <code>contest</code> has a <code>board</code>, which holds all the information about the state of the contest from the <code>game</code> perspective.</p>"},{"location":"lexicon/#move","title":"Move","text":"<p>A <code>move</code> is an action which can be done by a <code>player</code> on a given <code>board</code>.</p>"},{"location":"lexicon/#fog-of-war","title":"Fog-of-War","text":"<p>Some <code>game</code> have imperfect information: each <code>player</code> can only see the fraction of the <code>board</code>. In some such games, a <code>contender</code> can only see the <code>board</code> around its own unit ; the <code>fog-of-war</code> is the mechanism preventing a <code>contender</code> to see the board out of its units range-of-vision.</p>"},{"location":"lexicon/#gameover","title":"Gameover","text":"<p>A <code>contest</code> is <code>gameover</code> once its board state is final. No player will be able to submit a move ever.</p>"}]}